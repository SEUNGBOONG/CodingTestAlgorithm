# for 문 O(n)

- for depth 2 for

 ```
java
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
    // O(1) 작업
    }
}
 ```
- 이렇게 되면 시간 복잡도가 O(n²)입니다.  2억 * 20만
- 시간 복잡도 문제가 나오면 ? -> 이분 탐색을 사용한다.
- 이분 탐색이 검색 범위를 절반씩 줄이기 때문에,
- 최대 비교 횟수는 약 log₂(n)번이 됩니다. 
- 따라서 시간 복잡도는 O(log n)입니다.
  제한 시간이 1초 일 경우, N의 범위에 따른 시간 복잡도 선택
  N의 범위가 500: 시간 복잡도가 O(N^3) 이하인 알고리즘을 설계
  N의 범위가 2,000: 시간 복잡도가 O(N^2) 이하인 알고리즘을 설계
  N의 범위가 100,000: 시간 복잡도가 O(NlogN) 이하인 알고리즘을 설계
  N의 범위가 10,000,000: 시간 복잡도가 O(N) 이하인 알고리즘을 설계
  N의 범위가 10,000,000,000: 시간 복잡도가 O(logN) 이하인 알고리즘을 설계


